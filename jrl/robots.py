from typing import List

import torch
import numpy as np

from jrl.robot import Robot
from jrl.utils import get_filepath
from jrl.config import DEFAULT_TORCH_DTYPE, DEVICE


# Generated by scripts/calculate_ignorable_link_collision_pairs.py
FETCH_NEVER_COLLIDING_LINKS = [
    ("base_link", "shoulder_pan_link"),
    ("base_link", "shoulder_lift_link"),
    ("base_link", "upperarm_roll_link"),
    ("base_link", "head_tilt_link"),
    ("shoulder_pan_link", "upperarm_roll_link"),
    ("shoulder_pan_link", "elbow_flex_link"),
    ("shoulder_pan_link", "forearm_roll_link"),
    ("shoulder_pan_link", "wrist_flex_link"),
    ("shoulder_pan_link", "wrist_roll_link"),
    ("shoulder_pan_link", "head_tilt_link"),
    ("shoulder_lift_link", "elbow_flex_link"),
    ("shoulder_lift_link", "forearm_roll_link"),
    ("shoulder_lift_link", "wrist_flex_link"),
    ("shoulder_lift_link", "wrist_roll_link"),
    ("shoulder_lift_link", "head_tilt_link"),
    ("upperarm_roll_link", "forearm_roll_link"),
    ("upperarm_roll_link", "wrist_flex_link"),
    ("upperarm_roll_link", "wrist_roll_link"),
    ("upperarm_roll_link", "gripper_link"),
    ("elbow_flex_link", "wrist_flex_link"),
    ("elbow_flex_link", "wrist_roll_link"),
    ("elbow_flex_link", "gripper_link"),
    ("forearm_roll_link", "gripper_link"),
]
FETCH_ALWAYS_COLLIDING_LINKS = [("torso_lift_link", "shoulder_lift_link"), ("wrist_flex_link", "gripper_link")]
FETCH_ADDITIONAL_IGNORED_COLLISION_PAIRS = [
    ("torso_lift_link", "torso_fixed_link"),
    ("torso_lift_link", "shoulder_lift_link"),
    ("r_gripper_finger_link", "l_gripper_finger_link"),
    ("bellows_link2", "base_link"),
    ("bellows_link2", "torso_fixed_link"),
    ("wrist_flex_link", "gripper_link"),
]

PANDA_ALWAYS_COLLIDING_LINKS = []
PANDA_NEVER_COLLIDING_LINKS = [
    ("panda_link0", "panda_link2"),
    ("panda_link0", "panda_link3"),
    ("panda_link0", "panda_link4"),
    ("panda_link1", "panda_link3"),
    ("panda_link1", "panda_link4"),
    ("panda_link2", "panda_link4"),
    ("panda_link3", "panda_link5"),
    ("panda_link3", "panda_link6"),
    ("panda_link3", "panda_link7"),
    ("panda_link4", "panda_link6"),
    ("panda_link4", "panda_link7"),
]
FR3_NEVER_COLLIDING_LINKS = [
    ("fr3_link0", "fr3_link2"),
    ("fr3_link0", "fr3_link3"),
    ("fr3_link0", "fr3_link4"),
    ("fr3_link1", "fr3_link3"),
    ("fr3_link1", "fr3_link4"),
    ("fr3_link2", "fr3_link4"),
    ("fr3_link3", "fr3_link5"),
    ("fr3_link3", "fr3_link6"),
    ("fr3_link3", "fr3_link7"),
    ("fr3_link3", "fr3_hand"),
    ("fr3_link4", "fr3_link6"),
    ("fr3_link4", "fr3_link7"),
    ("fr3_link4", "fr3_hand"),
    ("fr3_link6", "fr3_hand"),
    ("fr3_link7", "fr3_link5"),  # these two don't actually collide if joint limits are respected
]
FR3_ALWAYS_COLLIDING_LINKS = [("fr3_rightfinger", "fr3_leftfinger"), ("fr3_hand", "fr3_link7")]

RIZON4_ALWAYS_COLLIDING_LINKS = []
RIZON4_NEVER_COLLIDING_LINKS = [
    ("base_link", "link2"),
    ("base_link", "link3"),
    ("base_link", "link4"),
    ("link1", "link3"),
    ("link1", "link4"),
    ("link2", "link4"),
    ("link2", "link5"),
    ("link3", "link5"),
    ("link3", "link6"),
    ("link3", "link7"),
    ("link4", "link6"),
    ("link4", "link7"),
]

UR5_NEVER_COLLIDING_LINKS = [
    ("base_link_inertia", "upper_arm_link"),
    ("upper_arm_link", "forearm_link"),
    ("upper_arm_link", "wrist_2_link"),
    ("upper_arm_link", "wrist_3_link"),
    ("wrist_1_link", "wrist_3_link"),
]

UR5_ALWAYS_COLLIDING_LINKS = [("base_link_inertia", "shoulder_link")]


def _load_capsule(path: str):
    data = np.loadtxt(get_filepath(path), delimiter=",")
    return torch.tensor(data, dtype=DEFAULT_TORCH_DTYPE, device=DEVICE)


# TODO(@jstmn): Fix batch FK for baxter
class Baxter(Robot):
    name = "baxter"
    formal_robot_name = "Baxter"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = -1  # TODO

    def __init__(self):
        active_joints = [
            "left_s0",
            "left_s1",
            "left_e0",
            "left_e1",
            "left_w0",
            "left_w1",
            "left_w2",
        ]

        base_link = "base"
        end_effector_link_name = "left_hand"

        urdf_filepath = get_filepath("urdfs/baxter/baxter.urdf")

        # TODO: set 'ignored_collision_pairs'
        ignored_collision_pairs = []
        Robot.__init__(
            self,
            Baxter.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            batch_fk_enabled=False,
        )


class Fetch(Robot):
    name = "fetch"
    formal_robot_name = "Fetch"

    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.08296040224661197

    def __init__(self):
        # Sum joint range: 34.0079 rads
        active_joints = [
            "torso_lift_joint",
            "shoulder_pan_joint",
            "shoulder_lift_joint",
            "upperarm_roll_joint",  # continuous
            "elbow_flex_joint",
            "forearm_roll_joint",  # continuous
            "wrist_flex_joint",
            "wrist_roll_joint",  # continuous
        ]
        base_link = "base_link"
        end_effector_link_name = "gripper_link"
        additional_link_name = "head_tilt_link"
        urdf_filepath = get_filepath("urdfs/fetch/fetch_formatted.urdf")

        # with additional ignored pairs, goes from 34 collision pair checks to 14
        ignored_collision_pairs = (
            FETCH_ADDITIONAL_IGNORED_COLLISION_PAIRS + FETCH_ALWAYS_COLLIDING_LINKS + FETCH_NEVER_COLLIDING_LINKS
        )

        collision_capsules_by_link = {
            link: _load_capsule(f"urdfs/fetch/capsules/{link}_collision.txt")
            for link in [
                "base_link",
                "torso_lift_link",
                "shoulder_pan_link",
                "shoulder_lift_link",
                "upperarm_roll_link",
                "elbow_flex_link",
                "forearm_roll_link",
                "wrist_flex_link",
                "wrist_roll_link",
                "gripper_link",
                "head_tilt_link",
            ]
        }
        Robot.__init__(
            self,
            Fetch.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            additional_link_name=additional_link_name,
        )


class FetchArm(Robot):
    name = "fetch_arm"
    formal_robot_name = "Fetch - Arm (no lift joint)"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.10705219156268285

    def __init__(self, verbose: bool = False):
        # Sum joint range: 33.6218 rads
        active_joints = [
            "shoulder_pan_joint",  # (-1.6056, 1.6056)
            "shoulder_lift_joint",  # (-1.221,  1.518)
            "upperarm_roll_joint",  # (-3.1415, 3.1415) continuous
            "elbow_flex_joint",  # (-2.251,  2.251)
            "forearm_roll_joint",  # (-3.1415, 3.1415) continuous
            "wrist_flex_joint",  # (-2.16,   2.16)
            "wrist_roll_joint",  # (-3.1415, 3.1415) continuous
        ]
        base_link = "base_link"
        end_effector_link_name = "gripper_link"
        additional_link_name = "head_tilt_link"
        urdf_filepath = get_filepath("urdfs/fetch/fetch_formatted.urdf")

        # with additional ignored pairs, goes from 34 collision pair checks to 14. This results in a ~2x speedup
        ignored_collision_pairs = (
            FETCH_ADDITIONAL_IGNORED_COLLISION_PAIRS + FETCH_ALWAYS_COLLIDING_LINKS + FETCH_NEVER_COLLIDING_LINKS
        )

        collision_capsules_by_link = {
            link: _load_capsule(f"urdfs/fetch/capsules/{link}_collision.txt")
            for link in [
                "base_link",
                "torso_lift_link",
                "shoulder_pan_link",
                "shoulder_lift_link",
                "upperarm_roll_link",
                "elbow_flex_link",
                "forearm_roll_link",
                "wrist_flex_link",
                "wrist_roll_link",
                "gripper_link",
                "head_tilt_link",
            ]
        }
        Robot.__init__(
            self,
            FetchArm.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=additional_link_name,
        )


class Panda(Robot):
    name = "panda"
    formal_robot_name = "Panda"

    # See 'Pose repeatability' in https://pkj-robotics.dk/wp-content/uploads/2020/09/Franka-Emika_Brochure_EN_April20_PKJ.pdf
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.14076593566091963

    def __init__(self, verbose: bool = False):
        active_joints = [
            "panda_joint1",  # (-2.8973, 2.8973)
            "panda_joint2",  # (-1.7628, 1.7628)
            "panda_joint3",  # (-2.8973, 2.8973)
            "panda_joint4",  # (-3.0718, -0.0698)
            "panda_joint5",  # (-2.8973, 2.8973)
            "panda_joint6",  # (-0.0175, 3.7525)
            "panda_joint7",  # (-2.8973, 2.8973)
        ]

        # Must match the total number of joints (including fixed) in the robot.
        # Use "None" for no collision geometry
        collision_capsules_by_link = {
            "panda_link0": _load_capsule("urdfs/panda/capsules/link0.txt"),
            "panda_link1": _load_capsule("urdfs/panda/capsules/link1.txt"),
            "panda_link2": _load_capsule("urdfs/panda/capsules/link2.txt"),
            "panda_link3": _load_capsule("urdfs/panda/capsules/link3.txt"),
            "panda_link4": _load_capsule("urdfs/panda/capsules/link4.txt"),
            "panda_link5": _load_capsule("urdfs/panda/capsules/link5.txt"),
            "panda_link6": _load_capsule("urdfs/panda/capsules/link6.txt"),
            "panda_link7": _load_capsule("urdfs/panda/capsules/link7.txt"),
            "panda_link8": None,
            "panda_hand": _load_capsule("urdfs/panda/capsules/hand.txt"),
        }

        urdf_filepath = get_filepath("urdfs/panda/panda_arm_hand_formatted.urdf")
        base_link = "panda_link0"
        end_effector_link_name = "panda_hand"
        # with additional ignored pairs, goes from 20 collision pair checks to 9. This results in a ~2x speedup
        ignored_collision_pairs = (
            [
                ("panda_hand", "panda_link7"),
                ("panda_rightfinger", "panda_leftfinger"),
                ("panda_link7", "panda_link5"),  # these two don't actually collide if joint limits are respected
            ]
            + PANDA_ALWAYS_COLLIDING_LINKS
            + PANDA_NEVER_COLLIDING_LINKS
        )

        Robot.__init__(
            self,
            Panda.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


class Fr3(Robot):
    """From google: 'The Franka Research 3 (FR3) is the successor to the Franka Emika Robot (FER)'

    Known changes vs Panda:
        - 'fr3_hand' has a slightly different shape
        - Includes the 'fr3_hand_tcp' link
        - Uses a updated urdf, as of Jan 15 2025 (source: https://github.com/frankaemika/franka_ros/tree/develop)
        - Different joint limits
    """

    name = "fr3"
    formal_robot_name = "Franka Emika Fr3"
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.1

    def __init__(self, verbose: bool = False):
        active_joints = [
            "fr3_joint1",  # (-2.7437, 2.7437)
            "fr3_joint2",  # (-1.7837, 1.7837)
            "fr3_joint3",  # (-2.9007, 2.9007)
            "fr3_joint4",  # (-3.0421, 0.1518)
            "fr3_joint5",  # (-2.8065, 2.8065)
            "fr3_joint6",  # (0.5445, 4.5169)
            "fr3_joint7",  # (-3.0159, 3.015)
        ]
        # Must match the total number of joints (including fixed) in the robot. Awkward, I know. This design is because
        # forward kinematics returns the pose of each joint link, instead of every link. This means we only know where
        # the links attached to joints are. A refactor to fix this would return the pose of every link in the kinematic
        # tree.
        collision_capsules_by_link = {
            "fr3_link0": _load_capsule("urdfs/fr3/capsules/fr3_link0.txt"),
            "fr3_link1": _load_capsule("urdfs/fr3/capsules/fr3_link1.txt"),
            "fr3_link2": _load_capsule("urdfs/fr3/capsules/fr3_link2.txt"),
            "fr3_link3": _load_capsule("urdfs/fr3/capsules/fr3_link3.txt"),
            "fr3_link4": _load_capsule("urdfs/fr3/capsules/fr3_link4.txt"),
            "fr3_link5": _load_capsule("urdfs/fr3/capsules/fr3_link5.txt"),
            "fr3_link6": _load_capsule("urdfs/fr3/capsules/fr3_link6.txt"),
            "fr3_link7": _load_capsule("urdfs/fr3/capsules/fr3_link7.txt"),
            "fr3_link8": None,
            "fr3_hand": torch.tensor([0, 0.08, 0.03, 0, -0.08, 0.03, 0.03]),
        }
        urdf_filepath = get_filepath("urdfs/fr3/fr3.urdf")
        base_link = "fr3_link0"
        end_effector_link_name = "fr3_hand"
        ignored_collision_pairs = FR3_ALWAYS_COLLIDING_LINKS + FR3_NEVER_COLLIDING_LINKS
        Robot.__init__(
            self,
            Fr3.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


class Iiwa7(Robot):
    name = "iiwa7"
    formal_robot_name = "Kuka LBR IIWA7"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.12614500942996015

    def __init__(self, verbose: bool = False):
        active_joints = [
            "iiwa_joint_1",
            "iiwa_joint_2",
            "iiwa_joint_3",
            "iiwa_joint_4",
            "iiwa_joint_5",
            "iiwa_joint_6",
            "iiwa_joint_7",
        ]
        urdf_filepath = get_filepath("urdfs/iiwa7/iiwa7_formatted.urdf")
        base_link = "world"
        end_effector_link_name = "iiwa_link_ee"
        collision_capsules_by_link = None  # TODO

        ignored_collision_pairs = []
        Robot.__init__(
            self,
            Iiwa7.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


class Iiwa14(Robot):
    name = "iiwa14"
    formal_robot_name = "Kuka LBR IIWA14"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.12614500942996015

    def __init__(self, verbose: bool = False):
        active_joints = [
            "joint_0",
            "joint_1",
            "joint_2",
            "joint_3",
            "joint_4",
            "joint_5",
            "joint_6",
        ]
        urdf_filepath = get_filepath("urdfs/iiwa14/iiwa14_formatted.urdf")
        base_link = "world"
        end_effector_link_name = "link_ee_kuka"
        collision_capsules_by_link = {
            "world": None,
            "link_0": _load_capsule("urdfs/iiwa14/capsules/link_0_s.txt"),
            "link_1": _load_capsule("urdfs/iiwa14/capsules/link_1_s.txt"),
            "link_2": _load_capsule("urdfs/iiwa14/capsules/link_2_s.txt"),
            "link_3": _load_capsule("urdfs/iiwa14/capsules/link_3_s.txt"),
            "link_4": _load_capsule("urdfs/iiwa14/capsules/link_4_s.txt"),
            "link_5": _load_capsule("urdfs/iiwa14/capsules/link_5_s.txt"),
            "link_6": _load_capsule("urdfs/iiwa14/capsules/link_6_s.txt"),
            "link_7": _load_capsule("urdfs/iiwa14/capsules/link_7-MF-Touch-pneumatisch_s.txt"),
            "link_ee": None,
            "link_ee_kuka": None,
            "link_ee_kuka_mft_pneum": None,
        }

        ignored_collision_pairs = []
        Robot.__init__(
            self,
            Iiwa14.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


class Rizon4(Robot):
    name = "rizon4"
    formal_robot_name = "Flexiv Rizon 4"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.12614500942996015

    def __init__(self, verbose: bool = False):
        active_joints = [
            "joint1",
            "joint2",
            "joint3",
            "joint4",
            "joint5",
            "joint6",
            "joint7",
        ]
        urdf_filepath = get_filepath("urdfs/rizon4/flexiv_rizon4_kinematics.urdf")
        base_link = "base_link"
        end_effector_link_name = "link7"

        # Must match the total number of joints (including fixed) in the robot.
        # Use "None" for no collision geometry
        collision_capsules_by_link = {
            "base_link": _load_capsule("urdfs/rizon4/capsules/link0.txt"),
            "link1": _load_capsule("urdfs/rizon4/capsules/link1.txt"),
            "link2": _load_capsule("urdfs/rizon4/capsules/link2.txt"),
            "link3": _load_capsule("urdfs/rizon4/capsules/link3.txt"),
            "link4": _load_capsule("urdfs/rizon4/capsules/link4.txt"),
            "link5": _load_capsule("urdfs/rizon4/capsules/link5.txt"),
            "link6": _load_capsule("urdfs/rizon4/capsules/link6.txt"),
            "link7": _load_capsule("urdfs/rizon4/capsules/link7.txt"),
        }

        ignored_collision_pairs = RIZON4_NEVER_COLLIDING_LINKS + RIZON4_ALWAYS_COLLIDING_LINKS
        Robot.__init__(
            self,
            Rizon4.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


class Ur5(Robot):
    name = "ur5"
    formal_robot_name = "UR5"

    # See
    # Rotational repeatability calculated in calculate_rotational_repeatability.py
    POSITIONAL_REPEATABILITY_MM = 0.1
    ROTATIONAL_REPEATABILITY_DEG = 0.12614500942996015

    def __init__(self, verbose: bool = False):
        active_joints = [
            "shoulder_pan_joint",
            "shoulder_lift_joint",
            "elbow_joint",
            "wrist_1_joint",
            "wrist_2_joint",
            "wrist_3_joint",
        ]
        urdf_filepath = get_filepath("urdfs/ur5/ur5_formatted.urdf")
        base_link = "base_link"
        # base_link = "base_link_inertia"
        end_effector_link_name = "wrist_3_link"

        # Must match the total number of joints (including fixed) in the robot.
        # Use "None" for no collision geometry
        collision_capsules_by_link = {
            "base_link_inertia": _load_capsule("urdfs/ur5/capsules/base.txt"),
            "forearm_link": _load_capsule("urdfs/ur5/capsules/forearm.txt"),
            "shoulder_link": _load_capsule("urdfs/ur5/capsules/shoulder.txt"),
            "upper_arm_link": _load_capsule("urdfs/ur5/capsules/upperarm.txt"),
            "wrist_1_link": _load_capsule("urdfs/ur5/capsules/wrist1.txt"),
            "wrist_2_link": _load_capsule("urdfs/ur5/capsules/wrist2.txt"),
            "wrist_3_link": _load_capsule("urdfs/ur5/capsules/wrist3.txt"),
        }

        ignored_collision_pairs = UR5_NEVER_COLLIDING_LINKS + UR5_ALWAYS_COLLIDING_LINKS
        Robot.__init__(
            self,
            Ur5.name,
            urdf_filepath,
            active_joints,
            base_link,
            end_effector_link_name,
            ignored_collision_pairs,
            collision_capsules_by_link,
            verbose=verbose,
            additional_link_name=None,
        )


ALL_CLCS = [Panda, Fetch, FetchArm, Rizon4, Ur5, Iiwa7, Iiwa14, Fr3]
# ALL_CLCS = [Ur5]
# TODO: Add capsules for iiwa7, fix FK for baxter
# ALL_CLCS = [Panda, Fetch, FetchArm, Iiwa7, Baxter]
ALL_ROBOT_NAMES = [clc.name for clc in ALL_CLCS]


def get_all_robots() -> List[Robot]:
    return [clc() for clc in ALL_CLCS]


def get_robot(robot_name: str) -> Robot:
    for clc in ALL_CLCS:
        if clc.name == robot_name:
            return clc()
    raise ValueError(f"Unable to find robot '{robot_name}' (available: {[clc.name for clc in ALL_CLCS]})")


def robot_name_to_fancy_robot_name(name: str) -> str:
    for cls in ALL_CLCS:
        if cls.name == name:
            return cls.formal_robot_name
    raise ValueError(f"Unable to find robot '{name}' (available: {[clc.name for clc in ALL_CLCS]})")
